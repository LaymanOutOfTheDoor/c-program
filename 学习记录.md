# 问题1

> lib/CMakeLists.txt中没有定义project src/CMakeLists.txt中定义了project(http-server VERSION 1.0 LANGUAGES C) 此时在俩CMakeLists.txt中插入打印语句 message( PROJECT_SOURCE_DIR---->: ${PROJECT_SOURCE_DIR}) 会打印什么？

在这种情况下，通过在lib/CMakeLists.txt和src/CMakeLists.txt中插入打印语句`message( PROJECT_SOURCE_DIR---->: ${PROJECT_SOURCE_DIR})`，会分别打印出不同的结果。

在lib/CMakeLists.txt中，由于没有定义`project`命令，`${PROJECT_SOURCE_DIR}`将不会被设置，所以打印语句将输出一个空字符串。

而在src/CMakeLists.txt中，使用了`project`命令定义了项目，`${PROJECT_SOURCE_DIR}`会被设置为项目的顶级目录，即该CMakeLists.txt所在的目录的路径。

所以在src/CMakeLists.txt中，打印语句将输出`PROJECT_SOURCE_DIR---->: <src所在目录的绝对路径>`。请根据实际情况替换`<src所在目录的绝对路径>`为具体路径。

总结：在lib/CMakeLists.txt中，打印结果为空字符串；在src/CMakeLists.txt中，打印结果为src目录的绝对路径。



# 问题2

> lib/CMakeLists.txt中没有定义project src/CMakeLists.txt中定义了project(http-server VERSION 1.0 LANGUAGES C) add_subdirectory(${CMAKE_SOURCE_DIR}/../lib ${CMAKE_SOURCE_DIR}/lib/build) 此时在俩CMakeLists.txt中插入打印语句 message( PROJECT_SOURCE_DIR---->: ${PROJECT_SOURCE_DIR}) 会打印什么？

> 在这种情况下，通过在lib/CMakeLists.txt和src/CMakeLists.txt中插入打印语句`message( PROJECT_SOURCE_DIR---->: ${PROJECT_SOURCE_DIR})`，会分别打印出不同的结果。
>
> 在lib/CMakeLists.txt中，由于没有定义`project`命令，`${PROJECT_SOURCE_DIR}`将不会被设置，所以打印语句将输出一个空字符串。
>
> 而在src/CMakeLists.txt中，使用了`project`命令定义了项目，`${PROJECT_SOURCE_DIR}`会被设置为src目录的绝对路径。因为你在src/CMakeLists.txt中添加了`add_subdirectory`命令，用于引入lib目录的CMakeLists.txt文件。
>
> 所以在src/CMakeLists.txt中，打印语句将输出`PROJECT_SOURCE_DIR---->: <src目录的绝对路径>`。请根据实际情况替换`<src目录的绝对路径>`为具体路径。
>
> 总结：在lib/CMakeLists.txt中，打印结果为空字符串；在src/CMakeLists.txt中，打印结果为src目录的绝对路径。

# 问题3

> 为什么我的俩目录下的CMakeLists.txt输出都是src的绝对路径？

> 在CMakeLists.txt文件中，`${PROJECT_SOURCE_DIR}`变量默认始终代表当前项目的顶级目录，而不是当前CMakeLists.txt所在的目录。不论在哪个子目录中的CMakeLists.txt文件中使用`${PROJECT_SOURCE_DIR}`，它都应该返回项目根目录的路径。
>
> 因此，在lib/CMakeLists.txt中使用`${PROJECT_SOURCE_DIR}`应该返回项目的根目录路径，而不是src目录的路径。
>
> 如果你在lib/CMakeLists.txt中输出的`${PROJECT_SOURCE_DIR}`结果实际上是src目录的绝对路径，那可能是因为在其他地方更改了`${PROJECT_SOURCE_DIR}`的值，或者有其他代码逻辑导致了这个问题。
>
> 请确保在lib/CMakeLists.txt文件中没有重定义或更改`${PROJECT_SOURCE_DIR}`变量的值，或者检查是否有其他地方可能会更改或引入这个变量。
>
> 如果问题仍然存在，建议检查一下整个项目的目录结构和CMakeLists.txt文件的内容，以确定是否有其他因素引起了`${PROJECT_SOURCE_DIR}`值的不同。

# 问题4

> 根目录下有lib目录和src目录并列存在， 已知lib/CMakeLists.txt中没有定义project 已知src/CMakeLists.txt中不仅定义了project(http-server VERSION 1.0 LANGUAGES C) 还定义了 add_subdirectory(${CMAKE_SOURCE_DIR}/../lib ${CMAKE_SOURCE_DIR}/lib/build) 请问在lib/CMakeLists.txt中插入message( PROJECT_SOURCE_DIR---->: ${PROJECT_SOURCE_DIR})，然后再在src/CMakeLists.txt中插入message( PROJECT_SOURCE_DIR---->: ${PROJECT_SOURCE_DIR}) 会输出什么？

> 在这种情况下，假设lib目录和src目录是根目录下的平级目录，并且在lib/CMakeLists.txt中插入`message( PROJECT_SOURCE_DIR---->: ${PROJECT_SOURCE_DIR})`，然后在src/CMakeLists.txt中也插入`message( PROJECT_SOURCE_DIR---->: ${PROJECT_SOURCE_DIR})`。
>
> 由于lib/CMakeLists.txt中没有定义`project`命令，`${PROJECT_SOURCE_DIR}`将不会被设置，因此在lib/CMakeLists.txt中的打印语句将输出一个空字符串。
>
> 在src/CMakeLists.txt中，通过`project`命令定义了项目，并且使用`add_subdirectory`命令将lib目录引入，并指定了构建目录为lib/build。由于`project`命令已经定义了顶级项目的根目录，`${PROJECT_SOURCE_DIR}`会被设置为根目录的路径。因此，在src/CMakeLists.txt中的打印语句将输出`PROJECT_SOURCE_DIR---->: <根目录的绝对路径>`。
>
> 所以，输出结果如下：
> 在lib/CMakeLists.txt中打印结果为为空字符串，即`PROJECT_SOURCE_DIR---->: `；
> 在src/CMakeLists.txt中打印结果为根目录的绝对路径，即`PROJECT_SOURCE_DIR---->: <根目录的绝对路径>`。

# 问题5

> 已知有俩并列目录lib和src 
>
> src/CMakeLists.txt定义如下： 
>
> ```cmake
> cmake_minimum_required(VERSION 3.15) 
> set(CMAKE_C_STANDARD 11) 
> project(http-server VERSION 1.0 LANGUAGES C) 
> #设置默认的安装目录 
> if (CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
>     set(CMAKE_INSTALL_PREFIX "${PROJECT_SOURCE_DIR}" CACHE PATH "Default install prefix" FORCE) 
> endif () 
> include_directories(${CMAKE_SOURCE_DIR}/../include) 
> #将 ${CMAKE_SOURCE_DIR}/../lib 目录添加为子目录， 
> #并在构建时使用 ${CMAKE_SOURCE_DIR}/../lib/build 作为输出目录 
> add_subdirectory(${CMAKE_SOURCE_DIR}/../lib ${CMAKE_SOURCE_DIR}/../lib/build)  
> add_executable(http-server main.c) include_directories(${CMAKE_SOURCE_DIR}/../lib) 
> target_include_directories(http-server PUBLIC ${CMAKE_SOURCE_DIR}/../lib) 
> if(${CMAKE_SYSTEM_NAME} STREQUAL "Windows")    
>     #Windows下的定义    
>     add_definitions(-DWINDOWS_DEFINITION-src)   
>     #使用target_link_libraries命令将库mylib与pthread库进行链接
>     #pthread库用于支持多线程编程
>     #可以带-l也可以不带
>     target_link_libraries(http-server PRIVATE ${CMAKE_SOURCE_DIR}/../build/lib/libmylib.dll)    
>     install(FILES ${CMAKE_SOURCE_DIR}/../lib/build/libmylib.dll DESTINATION ${CMAKE_SOURCE_DIR}/../build/lib) 
> elseif(${CMAKE_SYSTEM_NAME} STREQUAL "Linux") 
>     #Linux下的定义    
>     add_definitions(-DLINUX_DEFINITION-src)    
>     target_link_libraries(http-server PRIVATE ${CMAKE_SOURCE_DIR}/../build/lib/libmylib.so) 
>     install(FILES ${CMAKE_SOURCE_DIR}/../lib/build/libmylib.so DESTINATION ${CMAKE_SOURCE_DIR}/../build/lib) 
> endif()   
> install(TARGETS http-server DESTINATION ${CMAKE_SOURCE_DIR}/../build/bin) 
> install(FILES ${CMAKE_SOURCE_DIR}/../lib/build/config.h DESTINATION ${CMAKE_SOURCE_DIR}/../include) install(FILES ${CMAKE_SOURCE_DIR}/../lib/build/config.h DESTINATION ${CMAKE_SOURCE_DIR}/../include)  
> message(src: PROJECT_SOURCE_DIR---->: ${PROJECT_SOURCE_DIR})
> ```
>
> lib/CMakeLists.txt定义如下： 
>
> ```cmake
> cmake_minimum_required(VERSION 3.25) 
> file(GLOB SRC_FILES *.c) 
> add_library(mylib SHARED ${SRC_FILES}) 
> if(${CMAKE_SYSTEM_NAME} STREQUAL "Windows")    
>     add_definitions(-DWINDOWS_DEFINITION)    
>     target_link_libraries(mylib PUBLIC -lpthread PRIVATE ws2_32)
> elseif(${CMAKE_SYSTEM_NAME} STREQUAL "Linux")    
>     add_definitions(-DLINUX_DEFINITION)    
>     target_link_libraries(mylib pthread) 
> endif() 
> if (${POOL_SIZE})    
>     set(WORKER_POOL_SIZE ${POOL_SIZE}) 
> endif () 
> configure_file(${PROJECT_SOURCE_DIR}/config.h.cmake ${PROJECT_BINARY_DIR}/config.h)   
> message(lib：PROJECT_BINARY_DIR:----> ${PROJECT_BINARY_DIR}) 
> ```
>
> **为什么俩文件中的${PROJCET_SOURCE_DIR}都是：D:/Code/DemoFromGit/c-program/cmake/src**

> 根据你提供的CMakeLists.txt内容，可以解释为什么在lib/CMakeLists.txt和src/CMakeLists.txt中的`${PROJECT_SOURCE_DIR}`都是`D:/Code/DemoFromGit/c-program/cmake/src`。
>
> 在lib/CMakeLists.txt中，`${PROJECT_SOURCE_DIR}`是由顶层CMakeLists.txt文件中的`project`命令设置的。因为lib目录是位于根目录下的同级目录，通过`add_subdirectory`命令引入lib目录的CMakeLists.txt文件，`${PROJECT_SOURCE_DIR}`继承了根目录的路径。
>
> 同样的，在src/CMakeLists.txt中，`${PROJECT_SOURCE_DIR}`也是由顶层CMakeLists.txt文件中的`project`命令设置的，因此它被设置为根目录的路径。
>
> 因此，在lib/CMakeLists.txt和src/CMakeLists.txt中，`${PROJECT_SOURCE_DIR}`的输出都是`D:/Code/DemoFromGit/c-program/cmake/src`。
>
> 请注意，`${PROJECT_SOURCE_DIR}`的值是由顶层CMakeLists.txt文件中的`project`命令设置的。这个命令只在最顶层的CMakeLists.txt中执行一次，并且会传递给子目录中的CMakeLists.txt文件。所以在lib目录和src目录中的`${PROJECT_SOURCE_DIR}`都被设置为根目录的路径。

# 问题6----Cmake命令之add_subdirectory

> ### 一、介绍
>
> 该命令是**添加一个子目录并构建该子目录，**命令格式为
>
> ```
> add_subdirectory (source_dir [binary_dir] [EXCLUDE_FROM_ALL])
> ```
>
> 命令解析
>
> - **`source_dir`**
>   **必选参数**。该参数指定一个子目录，子目录下应该包含`CMakeLists.txt`文件和代码文件。子目录可以是相对路径也可以是绝对路径，如果是相对路径，则是相对当前目录的一个相对路径。
> - **`binary_dir`**
>   **可选参数**。该参数指定一个目录，用于存放输出文件。可以是相对路径也可以是绝对路径，如果是相对路径，则是相对当前输出目录的一个相对路径。如果该参数没有指定，则默认的输出目录使用`source_dir`。
> - **`EXCLUDE_FROM_ALL`**
>   **可选参数**。当指定了该参数，则子目录下的目标不会被父目录下的目标文件包含进去，父目录的`CMakeLists.txt`不会构建子目录的目标文件，必须在子目录下显式去构建。`例外情况：当父目录的目标依赖于子目录的目标，则子目录的目标仍然会被构建出来以满足依赖关系（例如使用了target_link_libraries）`。
>
> ### 二、实例
>
> 目录结构及说明如下：
>
> > ├── [CMakeLists](https://so.csdn.net/so/search?q=CMakeLists&spm=1001.2101.3001.7020).txt    #父目录的CMakeList.txt
> > ├── main.cpp    #源文件，包含main函数
> > ├── sub    #子目录
> >  └── CMakeLists.txt    #子目录的CMakeLists.txt
> >  └── test.h    #子目录头文件
> >  └── test.cpp    #子目录源文件
> >  
>
> 子目录`sub` 下的`test.cpp`定义了一个函数`test()`，将输入参数打印出来，相应的头文件`test.h`则对`test()`进行声明，`CMakelists.txt`则将`sub`下的源文件编译成库文件。
>
> ```
> //  sub/test.cpp  
> #include "test.h"
> #include <iostream>
> void test(std::string str)
> {
>     std::cout << str << std::endl;
> }
> //  sub/test.h
> #include <string>
> void test(std::string str);
> # sub/CMakeLists.txt
> cmake_minimum_required (VERSION 2.8)
> project(sub)
> add_library(sub test.cpp)
> # main.cpp
> #include "test.h"
> #include <iostream>
> int main(int argc, char** argv)
> {
>     std::cout << "In main..." << std::endl;
>     test("hello, world!");
>     return 0;
> }
> ```
>
> - **场景1**：父目录`CMakeLists.txt`的`add_subdirectory` 只指定了`source_dir`。
>
> ```
> # 父目录下的CMakeLists.txt
> cmake_minimum_required (VERSION 2.8)
> project(test)
> add_subdirectory(sub) 
> ```
>
> 在父目录下调用`cmake .`构建之后，在`sub`目录下会出现`libsub.a`库，说明当不指定`binary_dir`，输出目标文件就会放到`source_dir`目录下。
>
> - **场景2**：父目录`CMakeLists.txt`的`add_subdirectory` 指定了`source_dir`和`binary_dir`。
>
> ```
> # 父目录下的CMakeLists.txt
> cmake_minimum_required (VERSION 2.8)
> project(test)
> add_subdirectory(sub output) 
> ```
>
> 父目录下调用`cmake .`构建之后，在`output`目录下会出现`libsub.a`库，`sub`目录下则没有`libsub.a`。说明当指定`binary_dir`，输出目标文件就会放到`binary_dir`目录下。 
>
> **场景3**：父目录`CMakeLists.txt`的`add_subdirectory` 指定了`EXCLUDE_FROM_ALL`选项。
>
> ```
> # 父目录下的CMakeLists.txt
> cmake_minimum_required (VERSION 2.8)
> project(test)
> add_subdirectory(sub output EXCLUDE_FROM_ALL) 
> add_executable(test main.cpp)
> ```
>
>  在父目录下调用`cmake .`构建之后，在`output`目录或`sub`目录下`不会`出现`libsub.a`库，说明当指定`EXCLUDE_FROM_ALL`选项，子目录的目标文件不会生成。
>
> - **场景4**：父目录`CMakeLists.txt`的`add_subdirectory` 指定了`EXCLUDE_FROM_ALL`选项，且父目录的目标文件依赖子目录的目标文件。
>
> ```
> # 父目录下的CMakeLists.txt
> cmake_minimum_required (VERSION 2.8)
> project(test)
> add_subdirectory(sub output EXCLUDE_FROM_ALL) 
> add_executable(test main.cpp)
> target_link_libraries(test sub)
> ```
>
> 在父目录下调用`cmake .`构建之后，在`output`目录`会`出现`libsub.a`库，说明即使指定`EXCLUDE_FROM_ALL`选项，当父目录目标文件对子目录目标文件存在依赖关系时，子目录的目标文件仍然会生成以满足依赖关系。
>
> 最后，以一个完整的例子来结束本文（`sub`目录下的`CMakeList.txt`、`test.h`、`test.cpp`等文件内容如上文所示，没有变化），父目录下的`CMakeList.txt`如下：
>
> ```
> # 父目录下的CMakeLists.txt
> cmake_minimum_required (VERSION 2.8)
> project(test)
> include_directories(sub)
> add_subdirectory(sub output) 
> add_executable(test main.cpp)
> target_link_libraries(test sub)
> # 编译，运行
> # cmake ..
> # make 
> Scanning dependencies of target sub
> [ 25%] Building CXX object output/CMakeFiles/sub.dir/test.cpp.o
> [ 50%] Linking CXX static library libsub.a
> [ 50%] Built target sub
> Scanning dependencies of target test
> [ 75%] Building CXX object CMakeFiles/test.dir/main.cpp.o
> [100%] Linking CXX executable test
> [100%] Built target test
> >./test
> In main...
> hello, world!
> ```
>
> 参考：
>
> [add_subdirectory — CMake 3.22.1 Documentation](https://cmake.org/cmake/help/latest/command/add_subdirectory.html)
>
> [Cmake命令之add_subdirectory介绍 - 简书](https://www.jianshu.com/p/07acea4e86a3)



# 问题7----include_directories和target_include_directories

https://blog.csdn.net/qq_33726635/article/details/121896441

> 1、作用：
> 给源文件添加头文件搜索路径：将指定目录添加到编译器的头文件搜索路径之下，指定的目录被解释成当前源码路径的相对路径。
>
> 2、差别：
> 2.1、include_directories：
> 当前CMakeList.txt中的所有目标以及所有在其调用点之后添加的子目录中的所有目标将具有此头文件搜索路径。
>
> 2.2、target_include_directories：
> 指定目标包含的头文件路径。
>
> 3、用法：
>
> 3.1、include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 …])
> 例： include_directories(/usr1/dirs)
>
> 3.2、target_include_directories(<target> [SYSTEM] [AFTER|BEFORE] <INTERFACE|PUBLIC|PRIVATE> [items1…])
> 例： target_include_directories(target_so PUBLIC /usr1/dirs)
>
> 2.3、<INTERFACE|PUBLIC|PRIVATE>使用依据：
> INTERFACE：target对应的头文件使用
> PRIVATE：target对应的源文件使用
> PUBLIC：target对应的头文件、源文件都使用
>
> 如果有不同目录相同名称的头文件会产生影响，所以这里建议针对特定的target进行添加头文件的操作，不要使用include_directories
> ————————————————
> 版权声明：本文为CSDN博主「持续学习，不断沉淀」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
> 原文链接：https://blog.csdn.net/qq_33726635/article/details/121896441



# 问题8----CMake Install 安装第三方依赖库

https://blog.csdn.net/qq_30396367/article/details/127983063

> cmake 提供 install 命令来安装文件，方便打包。但是有时也会对第三方依赖库有需求一起打包，在不确定第三方库[dll文件](https://so.csdn.net/so/search?q=dll文件&spm=1001.2101.3001.7020)路径和名称的情况下，需要另一种方式来打包了。
>
> 比如想要打包opencv_world.dll，一般cmake依赖[opencv](https://so.csdn.net/so/search?q=opencv&spm=1001.2101.3001.7020)的方式是通过第三方软件包（* -config.cmake）的方式：
>
> ```
> # CMakeLists.txt
> find_package(OpenCV REQUIRED)
> target_link_libraries(my_project ${OpenCV_LIBS})
> ```
>
> 那么在install opencv时可以采用该宏自动找到opencv_world.dll并安装到目标路径下
>
> ```
> MACRO(INSTALL_IMPORTED_DLLS target_list target_component destination_dir)
>   foreach(target_dll ${target_list})
>     get_target_property(target_type ${target_dll} TYPE)
>     if (NOT target_type STREQUAL "INTERFACE_LIBRARY")
>        get_target_property(target_dll_location ${target_dll} IMPORTED_LOCATION_RELEASE)
>        if( one_trg_dll_location MATCHES ".dll$")
>           install(FILES ${target_dll_location} DESTINATION ${destination_dir} CONFIGURATIONS Release COMPONENT ${target_component})
>        endif()
>        get_target_property(target_dll_location ${target_dll} IMPORTED_LOCATION_DEBUG)
>        if( target_dll_location MATCHES ".dll$")
>           install(FILES ${target_dll_location} DESTINATION ${destination_dir} CONFIGURATIONS Debug COMPONENT ${target_component})
>        endif()
>     endif()
>   endforeach()
> ENDMACRO()
> 
> INSTALL_IMPORTED_DLLS(${OpenCV_LIBS} bin bin)
> ```
>
>  参考：[c++ - CMake - 安装第三方DLL依赖项 - Thinbug](https://www.thinbug.com/q/44650008)

# 如何修改 CMake 脚本以在构建过程中自动创建该目录

> 要在构建过程中自动创建目录，你可以使用 `file(MAKE_DIRECTORY ...)` 命令来创建目录。下面是一个示例：
>
> ```cmake
> # 检查构建目录是否存在
> if (NOT EXISTS ${CMAKE_SOURCE_DIR}/../build/)
>   # 创建构建目录
>   file(MAKE_DIRECTORY ${CMAKE_SOURCE_DIR}/../build/)
> endif()
> ```
>
> 在上述示例中，首先使用 `if (NOT EXISTS ...)` 条件语句检查构建目录是否存在。如果目录不存在，则使用 `file(MAKE_DIRECTORY ...)` 命令创建目录。
>
> 你可以将以上代码添加到你的 CMakeLists.txt 文件中，以确保在构建过程中自动创建构建目录。请注意根据你的实际情况修改目录路径。
>
> 希望这可以解决你的问题。如有其他疑问，请随时提问。